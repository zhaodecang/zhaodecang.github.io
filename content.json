[{"title":"Hexo主题yilia的自定义色彩搭配","date":"2017-01-18T12:06:38.000Z","path":"2017/01/18/custom_hexo_yilia/","text":"自定义代码块背景颜色、字体颜色以下颜色值的修改都是在/yilia/source/main.4a39e8.cs的基础上进行修改 背景颜色的修改 找到 .article-entry .highlight,.article-entry pre 样式块 修改 background 的值为期望的颜色值 保存 字体颜色的修改 找到 .article-entry pre code 样式块 修改 color 的值为期望的颜色值 保存并重新编译、部署 自定义引用块背景颜色、边框色以下颜色值的修改都是在/yilia/source/main.4a39e8.cs的基础上进行修改 修改引用快背景颜色 找到 .article-entry blockquote 样式块 修改 background 的值为期望的颜色值 保存 修改引用快边框样式 找到 .article-entry blockquote 样式块 修改 padding: 8px 20px 的值为期望的内边距值 修改 border-left: 2px solid #07A8E2 的值为期望的样式值 保存并重新编译、部署 ### 开启RSS功能 安装插件 npm install hexo-generator-feed --save 之后编辑主题目录下的_config.yml,添加如下代码 rss: /atom.xml #rss地址 默认即可","tags":[{"name":"Blog","slug":"Blog","permalink":"https://github.com/zhaodecang/tags/Blog/"}]},{"title":"最近项目总结笔记","date":"2017-01-17T10:00:43.000Z","path":"2017/01/17/newer_dev/","text":"Android动态初始化权限private void initPermission() { if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.M) { // 版本高于23才需要动态获取权限 int coarsePermission = getSelfPermission(Manifest.permission.ACCESS_COARSE_LOCATION); int finePerrmission = getSelfPermission(Manifest.permission.ACCESS_FINE_LOCATION); int granted = PackageManager.PERMISSION_GRANTED; if (coarsePermission != granted || finePerrmission != granted) { String[] permissions = { Manifest.permission.ACCESS_COARSE_LOCATION, Manifest.permission.ACCESS_FINE_LOCATION}; ActivityCompat.requestPermissions(this, permissions, REQUEST_CODE_LOCATION); } } } 判断是否已经获取权限 private int getSelfPermission(String permission) { return ContextCompat.checkSelfPermission(this, permission); } 获取授权的结果 @Override public void onRequestPermissionsResult(int requestCode, String[] permissions, int[] grantResults) { if (requestCode == REQUEST_CODE_LOCATION) { if (grantResults[0] == PackageManager.PERMISSION_GRANTED) { // 同意给予权限 } else { // 拒绝给予去权限 Toast.makeText(this, getString(R.string.request_permission_denied), Toast.LENGTH_SHORT).show(); } } } WebView使用时的相关配置private void initWebView(String loadUrl) { WebSettings settings = wvBrowser.getSettings(); settings.setUseWideViewPort(false);// 任意比缩放显示正常视图 settings.setSupportZoom(true);// 支持缩放 settings.setJavaScriptEnabled(true);// 支持JavaScript settings.setDefaultTextEncodingName(&quot;UTF-8&quot;);// 手动设置编码，解决乱码问题 settings.setLoadWithOverviewMode(true);// 缩放至屏幕大小 wvBrowser.loadUrl(loadUrl);// 加载数据 wvBrowser.requestFocus(); // 触摸焦点起作用 wvBrowser.setHorizontalScrollBarEnabled(false);// 取消垂直滚动条 wvBrowser.setVerticalScrollBarEnabled(false);// 取消水平滚动条 // 添加JavaScript调用Java函数的接口 wvBrowser.addJavascriptInterface(new JsInterface(BrowserActivity.this, wvBrowser), &quot;webService&quot;); initWebViewClient();// 初始化WebView的Client扩展 } 初始化WebView的Client扩展 private void initWebViewClient() { wvBrowser.setWebViewClient(new WebViewClient() { @Override public boolean shouldOverrideUrlLoading(WebView view, String url) { view.loadUrl(url); return true;// 如果返回false就会通过本机浏览器加载 } @Override public void onPageStarted(WebView view, String url, Bitmap favicon) { super.onPageStarted(view, url, favicon); pbLoading.setVisibility(View.VISIBLE); } @Override public void onPageFinished(WebView view, String url) { super.onPageFinished(view, url); pbLoading.setVisibility(View.INVISIBLE); } }); wvBrowser.setWebChromeClient(new WebChromeClient() { @Override public void onProgressChanged(WebView view, int newProgress) { pbLoading.setProgress(newProgress); } }); } 百度定位服务的管理类public class LocationManage { private LocationClient client = null; private LocationClientOption mOption, DIYoption; /** ** 同步锁 **/ private Object objLock = new Object(); /*** * @param locationContext */ public LocationManage(Context locationContext) { synchronized (objLock) { if (client == null) { client = new LocationClient(locationContext); client.setLocOption(getDefaultLocationClientOption()); } } } /*** ** 注册监听 */ public boolean registerListener(BDLocationListener listener) { boolean isSuccess = false; if (listener != null) { client.registerLocationListener(listener); LogUtil.i(this, &quot;百度定位服务注册成功&quot;); isSuccess = true; } return isSuccess; } /** ** 注销监听器 */ public void unregisterListener(BDLocationListener listener) { if (listener != null) { client.unRegisterLocationListener(listener); } } /** ** 添加配置项 */ public boolean setLocationOption(LocationClientOption option) { boolean isSuccess = false; if (option != null) { if (client.isStarted()) client.stop(); DIYoption = option; client.setLocOption(option); } return isSuccess; } public LocationClientOption getOption() { return DIYoption; } /** ** 获取默认配置项信息 */ public LocationClientOption getDefaultLocationClientOption() { if (mOption == null) { mOption = new LocationClientOption(); // 可选，默认高精度，设置定位模式，高精度，低功耗，仅设备 mOption.setLocationMode(LocationMode.Hight_Accuracy); // 可选，默认gcj02，设置返回的定位结果坐标系，如果配合百度地图使用，建议设置为bd09ll; // mOption.setCoorType(&quot;bd09ll&quot;); // 可选，默认0，即仅定位一次，设置发起定位请求的间隔需要大于等于1000ms才是有效的 mOption.setScanSpan(ConstantValue.LOCATION_INTEERVAL); // 可选，默认false，设置是否当gps有效时按照1S1次频率输出GPS结果 mOption.setLocationNotify(true); // 可选，默认true，定位SDK内部是一个SERVICE，并放到了独立进程，设置是否在stop的时候杀死这个进程，默认不杀死 mOption.setIgnoreKillProcess(true); // 可选，默认false，设置是否收集CRASH信息，默认收集 mOption.SetIgnoreCacheException(false); } return mOption; } public void start() { synchronized (objLock) { if (client != null &amp;&amp; !client.isStarted()) { LogUtil.i(this, &quot;开始定位&quot;); client.start(); } } } public void stop() { synchronized (objLock) { if (client != null &amp;&amp; client.isStarted()) { LogUtil.i(this, &quot;停止定位&quot;); client.stop(); } } } } 捕获全局异常并处理@Override public void uncaughtException(Thread t, Throwable e) { FileWriter fw = null; String json = buildLogInfoJson(buildLogInfo(t, e)); int count = SpUtil.getInt(context, ConstantValue.SP_KEY_ERRORLOG_SAVED, 0); if (FileUtil.checkSdCard() &amp;&amp; count &lt; 1) {// 如果SD卡挂载状态没有问题则保存数据 String logPath = FileUtil.getLogPath(); File file = new File(logPath); if (!file.exists()) file.mkdirs(); try { String logFilePath = logPath + ConstantValue.LOGINFO_FILE_NAME; LogUtil.i(MsUnCaughtException.this, &quot;错误日志信息保存在:&quot; + logFilePath); if (new File(logFilePath).exists()) { json = &quot;,&quot; + json;// 如果已经存在日志信息就追加“,” } fw = new FileWriter(logFilePath, true); fw.write(json); LogUtil.e(&quot;保存的json数据为：&quot;, json); } catch (IOException e1) { LogUtil.e(&quot;全局异常&quot;, &quot;创建异常信息文件失败：&quot; + e1.getCause()); e1.printStackTrace(); } finally { FileUtil.closeSafty(fw); } } if (count == 2) count = -1; SpUtil.putInt(context, ConstantValue.SP_KEY_ERRORLOG_SAVED, count + 1); e.printStackTrace(); Process.killProcess(Process.myPid());// 自杀重启 }","tags":[{"name":"Note","slug":"Note","permalink":"https://github.com/zhaodecang/tags/Note/"}]},{"title":"博客系统搭建之路","date":"2017-01-15T14:35:01.000Z","path":"2017/01/15/article-title/","text":"搭建自己的简易博客系统很早就想搭建一个自己的博客系统记录平时所学的点点滴滴，今天得空看见郭神的一篇文章写的真心不错，故而班门弄斧搭了一个自己的博客，借此在自己的博客系统上分享搭建博客过程中的关键步骤和遇到的问题。 配置Node.js环境 下载Node.js安装文件： Windows Installer 32-bit https://nodejs.org/dist/v4.2.3/node-v4.2.3-x86.msi Windows Installer 64-bit https://nodejs.org/dist/v4.2.3/node-v4.2.3-x64.msi 安装并检查 安装过程纯粹就是“懒人式”安装，一路默认next 安装完成之后再命令行窗口输入： node -vnpm -v 如果输出版本信息说明安装成功，可以进行下一步了，如果不正确，则需要回头检查自己的安装过程。 配置Git环境 下载Git安装文件：https://git-scm.com/downloads 然后开始安装： 安装初始界面如下： 和 Node.js 一样，大部分设置都只需要保持默认，但是出于我们操作方便考虑，建议 PATH 选项按照下图选择： 剩余操作一路默认、next，安装完成之后打开命令行窗口，输入 git –version 如果结果如下图所示，则说明安装正确，可以进行下一步了，如果不正确，则需要回头检查自己的安装过程。 Github账号的注册和配置 Github注册（如果已有账号，请跳过此步……） 打开 Github 在下图的输入框中，分别输入自己的用户名、邮箱、密码: 然后前往自己刚才填写的邮箱，点开 Github 发送给你的注册确认信，确认注册，结束注册流程。一定要确认注册，否则无法使用gh-pages！ 创建代码库 登陆之后，点击页面右上角的加号，选择 New repository： 进入代码库创建页面，在 Repository name下填写 yourname.github.io，Description (optional) 下填写一些简单的描述（不写也没有关系）如图所示： 代码库设置 正确创建之后，你将会看到如下界面： 接下来开启点击界面右侧的 Settings，你将会打开这个库的 setting 页面，向下拖动，直到看见 GitHub Pages，如图： 如果你的配置没有问题，那么大约15分钟之后，yourname.github.io 这个网址就可以正常访问了~ 如果看到的界面没有 Your site is published at https://yourname.github.io/ 这行文字，说明之前创建仓库时没有生成README文件， 这时点击菜单栏左侧Code页签，点击底部的提示并创建一个README文件 安装Hexo在自己认为合适的地方创建一个文件夹，这里我以D：Program/hexo 为例，首先在D盘Program目录下创建Hexo文件夹，并在空白处右键选择 在此处打开命令行窗口 进入到该目录，然后在命令行输入： npm install hexo-cli -g 然后将会看到如下提示： 可能你会看到一个WARN，但是不用担心，这不会影响你的正常使用。 然后输入： npm install hexo --save 然后你会看到命令行窗口刷了一大堆白字，下面我们来看一看Hexo是不是已经安装好了。 在命令行中输入： hexo -v 如果你看到了如图文字，则说明已经安装成功了。 Hexo相关配置 初始化Hexo 接着上面的操作，输入： hexo init 然后输入： npm install 之后 npm 将会自动安装你需要的组件，只需要等待 npm 操作即可。 首次体验Hexo 继续操作，同样是在命令行中，输入： hexo g 然后输入： hexo s 然后会提示：INFO Hexo is running at http://0.0.0.0:4000/. Press Ctrl+C to stop 在浏览器中打开 http://localhost:4000，你将会看到： 到目前为止，Hexo在本地的配置已经全都结束了。下面的步骤是将Github page与本地Hexo联系起来。 将Hexo与github page 联系起来 配置Git个人信息 如果你之前已经配置好git个人信息，请跳过这个步骤 检查是否已经有SSH Key cd C:\\Users\\Administrator.sshls 列出该文件下的文件，看是否存在 id_isa 和 id_isa.pub 文件，如果存在的话证明已经存在 SSH Key了，可以直接跳过生成密钥这一步骤，以下是存在的情况： 设置 Git 的 user name 和 email： git config –global user.name “zhaodecang”git config –global user.email “zhaodecang@qq.com” 生成密钥 ssh-keygen -t rsa -C “zhaodecang@qq.com” 连续两个回车(SSH Key会默认保存在C:\\Users\\Administrator.ssh目录下)，如果不需要密码则一路回车 添加密钥到ssh-agent 确保 ssh-agent 是可用的。ssh-agent是一种控制用来保存公钥身份验证所使用的私钥的程序，其实ssh-agent就是一个密钥管理器，运行ssh-agent以后，使用ssh-add将私钥交给ssh-agent保管，其他程序需要身份验证的时候可以将验证申请交给ssh-agent来完成整个认证过程。 start the ssh-agent in the backgroundeval “$(ssh-agent -s)” 添加生成的 SSH key 到 ssh-agent ssh-add ~/.ssh/id_rsa 登录Github添加SSH 登录Github之后按如下步骤进入添加SSH的界面 然后点击右上角的NewSSHKey，把id_rsa.pub文件里的内容复制到Key里 测试SSH ssh -T git@github.com 你将会看到： Hi zhaodecang! You’ve successfully authenticated, but GitHub does not provide shell access. 如果看到Hi后面是你的用户名，就说明成功了 配置Deployment 在Hexo目录下的 _config.yml 文件中，找到 Deployment，然后按照如下修改： deploy:type: gitrepo: git@github.com:zhaodecang/zhaodecang1.github.io.gitbranch: master 写博客、发布文章 执行如下命令，新建一篇博客： hexo new post “article title” 这时候在Hexo目录 \\hexo\\source_posts 下将会看到 article title.md 文件，用MarkDown编辑器打开就可以编辑文章了。文章编辑好之后运行生成、部署命令： hexo g // 生成hexo d // 部署 当然也可以执行下面的命令，相当于上面两条命令的效果： hexo d -g #在部署前先生成 部署成功后访问你的地址 https://yourName.github.io将可以看到生成的文章 踩坑提醒 注意需要提前安装一个扩展： npm install hexo-deployer-git –save 如果出现下面这样的错误： permission denied (publickey).fatal:Could not read from remote repository.please make sure you hava the correct access rights and the repository exists. 则是因为没有设置好public key所致，可以重新查看上面配置Git和Deployment部分 另外推荐一篇博客 http://blog.csdn.net/gdutxiaoxu/article/details/53573399 添加404页面 GitHub Pages有提供制作404页面的指引： Custom 404 Pageshttps://help.github.com/articles/creating-a-custom-404-page-for-your-github-pages-site 直接在根目录下创建自己的 404.html 或者 404.md 就可以。但是自定义404页面仅对绑定顶级域名的项目才起作用，GitHub默认分配的二级域名是不起作用的，使用 hexo server 在本机调试也是不起作用的。 推荐使用，腾讯公益404： http://www.qq.com/404 我的404页面配置如下： 参考 Hexo主页 https://hexo.io 史上最详细的Hexo博客搭建图文教程 https://xuanwo.org/2015/03/26/hexo-intor","tags":[{"name":"Note","slug":"Note","permalink":"https://github.com/zhaodecang/tags/Note/"}]}]